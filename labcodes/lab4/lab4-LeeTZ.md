操作系统Lab4实验报告
===================
计14班 李铁峥 2011011268

-------------------

1. 练习1：分配并初始化一个进程控制块

设计思路：

创建一个进程的准备工作用代码体现就是给proc_struct中的各个结构成员赋值。默认的进程状态是PROC_UNINIT，pid等待稍后被赋值，先取-1，其余如栈，地址空间等均取0

 - 请说明proc_struct中 struct  context context 和   struct  trapframe   *tf 成员变量含义和在本实验中的作用是啥？

 这里context是用来保存进程的上下文，其中的成员变量是8个寄存器的值。作用为在进程切换时保存和回复现场。
 trapframe是进程的中断帧。ucore在创建init_main的时候内核线程初始化了它的中断帧。这里记录内核的代码段，数据段，以及进程的入口地址等。

 2. 练习2：为新创建的内核线程分配资源

 设计思路：

 为新进程分配进程控制块PCB，之后将父进程的pid设置为当前进程，初始化栈结构，复制地址空间，再将进程执行的状态用copy_thread拷贝到新的栈与地址空间中。为新进程的pid赋值，并将PCB加入到proc_list与hash表中，最后调用wakeup_proc，唤醒进程，准备执行。

 - 请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。

 是。ucore可保证每个进程的pid唯一。在proc.c中定义了MAX_PROCESS与MAX_PID宏，而MAX_PID是MAX_PROCESS的2倍，在get_pid函数中，每次遍历整个进程链表确保每个现有进程的pid与选中的last_pid不同。另外将MAX_PID设为MAX_PROCESS的2倍，且将next_safe和last_pid作为静态变量记录上次pid的分配状态都可以加速这个唯一性寻找的过程。


 3. 练习3： 阅读代码，理解   proc_run    函数和它调用的函数如何完成进程切换的。

2个内核线程，idleproc与initproc，前者用于一些基本的初始化工作使程序进入调度状态（使用cpu_idle）。后者用于执行init_main函数来做进一步的初始化工作。这2条语句用于关闭中断和恢复中断，在lab4中，ucore在向终端输出字符、分配物理页帧、释放页、进程调度时都会先关闭中断，操作完成后再开启中断。

## 与参考答案的对比

由于大部分的实现遵照注释，本实验的编码量也并不很大，所以与参考答案基本没有不同。

## 实验中的知识点

实验中对进程调度时的PCB结构描述的比较清楚，从单进程运行到多进程调度的实现过程也较为明晰，主要体现在idleproc和initproc的创建。

## 原理课中的知识点

原理课中叙述的进程的各种状态以及进程的控制功能还没有体现。



