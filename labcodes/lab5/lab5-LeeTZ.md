操作系统Lab5实验报告
===================
计14班 李铁峥 2011011268

-------------------

1. 练习1：加载应用程序并执行

设计思路：

设置tf的过程就是各段寄存器，栈结构和上下文的初始化。

cs设置为USER_CS，ds,es,ss均赋值为USER_DS，使其拥有用户级的特权。esp为用户栈顶端，eip为程序入口地址，eflags寄存器中打开中断位。

-请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即 这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

当进程进入到RUNNING状态时，proc_run函数会再放入进程的kstack与cr3页表，调用switch_to函数进行切换。被调用的汇编代码在switch.S中。该段代码将进程当前执行到的eip压栈，在ret跳转到eip处执行。

之前load_icode已将eip设成了程序entry并设置好了用户态tf和对应寄存器，如此一来，跳转后就在用户态工作了。


 2. 练习2：父进程复制自己的内存空间给子进程


 - 请在实验报告中简要说明如何设计实现”Copy on Write   机制“，给出概要设计，鼓励给出详细设计。

Copy-on-write的基本概念是指如果有多个使用者对一个资源A（比如内存块）进行读操作，则每个使用 者只需获得一个指向同一个资源A的指针，就可以该资源了。若某使用者需要对这个资源A进行写操作，系统会对该资 源进行拷贝操作，从而使得该“写操作”使用者获得一个该资源A的“私有”拷贝—资源B，可对资源B进行写操作。该“写操 作”使用者对资源B的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源A。

实现的思路大致如下：在进程fork时可将子进程的cr3寄存器设置为与父进程相同。并将父进程的页表项全设为只读，这样父子进程可读取相同的页面，而当某个进程试图写页面时会出发page fault异常，此时中断服务检查是否是COW的情况，调用copy_range函数拷贝对应的页面到新的内存空间，令进程完成写操作即可。


 3. 练习3：阅读分析源代码，理解进程执行  fork/exec/wait/exit 的实现，以及系统调用的实现

do_fork中会对进程进行初始化，然后调用wakup_proc函数将进程状态设置为RUNNABLE等待分配时间片。

do_execve中没有修改进程的状态，仅仅拷贝了可执行二进制代码。

do_wait中会对进程的子进程进行检测，如果其子进程都已经结束或都是僵尸进程，则直接结束这个进程释放资源。如果其子进程还没有结束，则将其置于SLEEPING状态。

do_exit中会释放一个进程所占用的资源，将其变为ZOMBIE状态，然后判断其父进程是否处于等待状态（WT_CHILD），如果是则调用wakeup_proc唤醒父进程。若此进程含有子进程，则将子进程交由内核线程initproc处理。

周期图：

alloc_proc do_fork/wakeup_proc | do_wait | ----------------> PROC_UNINIT ----------------------> PROC_RUNNABLE -----------------> PROC_SLEEPING | <----------------- | do_exit
| | | | do_wait | | | \ / (freed) ···


## 与参考答案的对比

由于大部分的实现遵照注释，本实验的编码量也并不很大，所以与参考答案基本没有不同。

## 实验中的知识点

实验中对用户进程的产生过程和实现方式叙述的非常清楚。

## 原理课中的知识点

原理课中叙述的PCB还没有体现。



