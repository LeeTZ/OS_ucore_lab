操作系统Lab7实验报告
===================
计14班 李铁峥 2011011268

-------------------

1. 练习1：给出内核级信号量的设计描述，并说其大致执行流程。

首先我们关注semaphore_t的定义：

```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
value为能够同时进入临界区的进程数目，wait_queue是在临界区外等待的进程队列。
信号量结构提供的接口为进入临界区的down()函数与离开临界区的up()函数。

大致的执行流程为：调用down函数-->wait_current_set进入等待队列-->PROC_SLEEPING睡眠-->其他进程调用up函数-->wakeup_proc被唤醒-->进入临界区执行-->调用up函数-->其他进程进入临界区或者value++。



1. 练习1：给出用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。

用户态进程/线程的的信号量机制主要用于用户态进程间进行同步互斥操作，原理上与内核级信号量相同，只需要对用户的接口需要进行进一步的封装，在内核级信号量的基础上，将接口开放给用户。

与内核级信号量的相同点是都为了实现同步互斥机制，不同点在于内核中实现同步互斥是为了底层资源的共享与保护，而用户态则是用户自己的资源共享与保护。


 2. 练习2：给出内核级条件变量的设计描述，并说其大致执行流程。

内核级条件变量依靠信号量机制实现。

在monitor.h中定义了条件变量结构condvar_t与管程结构monitor_t。其中条件变量提供了2个操作cond_wait与cond_signal，分别用于进程挂起与发出信号。

对于每个管程，都提供有一个信号量mutex，进程在进入管程之前必须执行wait(mutex)，离开管程之后必须执行signal(mutex)。next_count记录挂起在next上的进程数量。 

在挂起时，检查信号量不为0，则可以进入临界区。

发出信号时候，进程将离开管程，此时将next_count加1，随后释放cv.sem信号量，接着它会等待下一个next信号以便再次进入管程。


 2. 练习2：给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。
 与上个问题相同，本质并无二异，只需要对用户重新封装。


## 与参考答案的对比

这次的实验大部分由伪代码，实现较为接近。

## 实验中的知识点

本次实验重要的就是管程和信号量的实现和分别它们的不同点。

## 原理课中的知识点

只选取了课程中的一个问题来实现，其余的没有用代码来体现。



